/*
 * ====================================================================
 * Project:     openmdx, http://www.openmdx.org/
 * Name:        $Id: PersonImpl.jt,v 1.10 2008/02/14 13:07:05 wfro Exp $
 * Description: class PersonImpl
 * Revision:    $Revision: 1.10 $
 * Owner:       OMEX AG, Switzerland, http://www.omex.ch
 * Date:        $Date: 2008/02/14 13:07:05 $
 * ====================================================================
 *
 * This software is published under the BSD license as listed below.
 * 
 * Copyright (c) 2004-2007, OMEX AG, Switzerland
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the following
 * conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in
 *   the documentation and/or other materials provided with the
 *   distribution.
 * 
 * * Neither the name of the openMDX team nor the names of its
 *   contributors may be used to endorse or promote products derived
 *   from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * ------------------
 * 
 * This product includes or is based on software developed by other 
 * organizations as listed in the NOTICE file.
 */
package org.openmdx.test.test.app1.plugin.jmi;

import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.Iterator;
import java.util.Set;

import javax.jmi.reflect.JmiException;
import javax.jmi.reflect.RefException;

import org.openmdx.base.accessor.jmi.cci.JmiServiceException;
import org.openmdx.base.accessor.jmi.cci.RefObject_1_0;
import org.openmdx.base.accessor.jmi.spi.RefObject_1;
import org.openmdx.base.event.InstanceCallbackEvent;
import org.openmdx.base.event.InstanceCallbackListener;
import org.openmdx.base.exception.ServiceException;
import org.openmdx.kernel.exception.BasicException;

import javax.xml.datatype.DatatypeConstants;
import javax.xml.datatype.DatatypeConfigurationException;
import javax.xml.datatype.DatatypeFactory;
import javax.xml.datatype.XMLGregorianCalendar;

#if defined(BEFORE16)
import org.openmdx.base.jmi.BasePackage;
import org.openmdx.test.app1.jmi.App1Package;
import org.openmdx.test.app1.cci.CanNotFormatNameException;
import org.openmdx.test.app1.cci.InternationalPostalAddress;
import org.openmdx.test.app1.cci.Person;
import org.openmdx.test.app1.cci.PersonAssignAddressParams;
import org.openmdx.test.app1.cci.PersonDateOpParams;
import org.openmdx.test.app1.cci.PersonDateOpResult;
import org.openmdx.test.app1.cci.PersonFormatNameAsParams;
import org.openmdx.test.app1.cci.PersonFormatNameAsResult;
#else
import java.util.TreeMap;
import org.openmdx.base.jmi1.BasePackage;
import org.openmdx.test.app1.jmi1.App1Package;
import org.openmdx.test.app1.jmi1.CanNotFormatNameException;
import org.openmdx.test.app1.jmi1.InternationalPostalAddress;
import org.openmdx.test.app1.jmi1.Person;
import org.openmdx.test.app1.jmi1.PersonAssignAddressParams;
import org.openmdx.test.app1.jmi1.PersonDateOpParams;
import org.openmdx.test.app1.jmi1.PersonDateOpResult;
import org.openmdx.test.app1.jmi1.PersonFormatNameAsParams;
import org.openmdx.test.app1.jmi1.PersonFormatNameAsResult;
import org.w3c.cci2.SortedMaps;
#endif

/**
 *
 */
public class PersonImpl
  extends RefObject_1
  implements InstanceCallbackListener 
{ 
    
    /**
	 * Implements <code>Serializable</code>
	 */
	private static final long serialVersionUID = -8893974557731297760L;

  	public PersonImpl(
    	Person delegate
  	) {
    	super(
      		((RefObject_1_0)delegate).refDelegate(), // TODO
      		delegate.refClass()
    	);
    	this.delegate = delegate;
  	}
      
    /**            
     *
     */
	public Set refDefaultFetchGroup(
  	) {
	    Set group = super.refDefaultFetchGroup();
	    group.add("age");
	    group.add("creationDateTime");
	    return group;
  	}
    
    /**
     * Retrieves the value for the attribute <code>age</code>.
     * @return The non-null value for attribute <code>age</code>.
     * @exception JmiException If the value cannot be retrieved for some reason.
     */
  	public short getAge(
  	) throws JmiException {
    	int currentYear = Calendar.getInstance().get(Calendar.YEAR);
    	int birthdateYear = this.delegate.getBirthdate().getYear();
   		return (short)(currentYear - birthdateYear);
  	}
  
    /**
     * Retrieves the value for the attribute <code>creationDateTime</code>.
     * @return The non-null value for attribute <code>creationDateTime</code>.
     * @exception JmiException If the value cannot be retrieved for some reason.
     */
    public Date getCreationDateTime(
    ) {
	    return this.delegate.getCreatedAt();
 	}
  
    /**
     * Retrieves a list containing all the elements for the reference <code>matchingAddress</code>.
     * @return A list containing all the elements for this reference.
     * @exception JmiException If the values cannot be retrieved for some reason.
     */
    public Collection getMatchingAddress(
    ) throws JmiException {
        return null;
    }

    public PersonFormatNameAsResult formatNameAs(
        PersonFormatNameAsParams params
    ) throws CanNotFormatNameException {
	    // default format "Standard"
	    if((params.getType() == null) || "Standard".equals(params.getType())) {
	        StringBuffer givenNames = new StringBuffer();
	        int ii = 0;
	        for(
	          	Iterator i = this.delegate.getGivenName().iterator();
	          	i.hasNext();
	          	ii++
	        ) {
	          	if(ii > 0) {
	            	givenNames.append(" ");
	          	}
	        	givenNames.append((String)i.next());
	       	}
	      	String formattedName = this.delegate.getSalutation() + " " + givenNames.toString() + " " + this.delegate.getLastName();
	      	return ((App1Package)this.refImmediatePackage()).createPersonFormatNameAsResult(
	        	formattedName,
	        	Collections.singletonList(formattedName),
	        	Collections.singleton(formattedName),
#if defined(BEFORE16)
	        	Collections.singletonList(formattedName)
#else
                SortedMaps.asSparseArray(new TreeMap<Integer, String>(Collections.singletonMap(0, formattedName)))
#endif
	      	);
	    } else {
	    
	    // format not supported
	      	throw new CanNotFormatNameException(
#if defined(BEFORE16)
	        	BasicException.Code.DEFAULT_DOMAIN,
	        	BasicException.Code.ASSERTION_FAILURE,
	        	"name format not supported. Supported are [Standard]", 
#else
	        	// TODO
#endif
	        	params.getType()
	      	);
	    }  
  	}

	/**    
	 *
	 */
#if defined(BEFORE16)
  	public org.openmdx.base.cci.Void assignAddress(
#else
  	public void assignAddress(
#endif
    	PersonAssignAddressParams params
  	) throws RefException {
    	BasePackage basePkg = (BasePackage)this.refOutermostPackage().refPackage("org:openmdx:base");
    	System.out.println("assigning addresses=" + params.getAddress());
#if defined(BEFORE16)
    	return basePkg.createVoid();
#endif
  	}

    /**
     * voidOp adds the country code to all assigned austrian, swiss and german postal addresses.
     */
#if defined(BEFORE16)
  	public org.openmdx.base.cci.Void voidOp(
    	org.openmdx.base.cci.Void params
#else
  	public void voidOp(
#endif
  	) throws RefException  {
    	BasePackage basePkg = (BasePackage)this.refOutermostPackage().refPackage("org:openmdx:base");
    	for(
      		Iterator i = this.delegate.getAssignedAddress().iterator();
      		i.hasNext();
    	) {
      		RefObject_1_0 address = (RefObject_1_0)i.next();
      		if(address instanceof InternationalPostalAddress){
        		InternationalPostalAddress postalAddress = (InternationalPostalAddress)address;
        		int j = Arrays.asList(COUNTRY_NAME).indexOf(postalAddress.getCountry());
        		if(j >= 0) {
          			String countryPrefix = COUNTRY_CODE[j % COUNTRY_CODE.length] + '-';
          			String postalCode = postalAddress.getPostalCode();
          			if(! postalCode.startsWith(countryPrefix)) postalAddress.setPostalCode(
            			countryPrefix + postalCode
          			);
        		}
      		}
    	}
#if defined(BEFORE16)
    	return basePkg.createVoid();
#endif
  	}

	/**
	 *
	 */
  	public PersonDateOpResult dateOp(
    	PersonDateOpParams params
  	) throws javax.jmi.reflect.RefException {
    	System.out.println("dateOp.dateIn=" + params.getDateIn());
    	System.out.println("dateOp.dateTimeIn=" + params.getDateTimeIn());
    	XMLGregorianCalendar date = xmlDatatypeFactory().newXMLGregorianCalendarDate(
        	2004,
        	12,
        	12,
        	DatatypeConstants.FIELD_UNDEFINED
    	);
    	return ((App1Package)this.refImmediatePackage()).createPersonDateOpResult(
	        date,
	        new Date()
	    );
 	}

	/**  
	 *
	 */
  	private final static String[] COUNTRY_CODE = new String[]{
    	"AT", "DE", "CH"
  	};
	
	/**
	 *
	 */
  	private final static String[] COUNTRY_NAME = new String[]{
    	"Austria", "Germany", "Switzerland", 
    	"Österreich", "Deutschland", "Schweiz",
    	"Autriche", "Allemagne", "Suisse",
    	"Austria", "Germania", "Svizzera"
  	};
  
  	//--------------------------------------------------------------------------
  	// Implements InstanceCallbackListener
  	//--------------------------------------------------------------------------

	/**
	 *
	 */
    public void postLoad(InstanceCallbackEvent event) throws ServiceException {
        //System.out.println(this.getClass().getName() + ".objPostLoad"); 
    }
    
	/**
	 *
	 */
    public void preStore(InstanceCallbackEvent event) throws ServiceException {
        //System.out.println(this.getClass().getName() + ".objPreStore"); 
        if(!this.refIsDeleted()) {
          int sex = this.delegate.getSex();
          String salutation = this.delegate.getSalutation();
          if((sex == 0) && !("Herr".equals(salutation) || "Mister".equals(salutation) || "Monsieur".equals(salutation))) {
            throw new JmiServiceException(
              new ServiceException(
                BasicException.Code.DEFAULT_DOMAIN,
                BasicException.Code.ASSERTION_FAILURE, 
                new BasicException.Parameter[]{
                  new BasicException.Parameter("object", this)
                },
                "sex 0 implies salutation [Herr|Mister|Monsieur]"
              )
            );
          }
        }    
    }
    
	/**
	 *
	 */
    public void preClear(InstanceCallbackEvent event) throws ServiceException {
        //System.out.println(this.getClass().getName() + ".objPreClear"); 
    }
    
	/**
	 *
	 */
    public void preDelete(InstanceCallbackEvent event) throws ServiceException {
        //System.out.println(this.getClass().getName() + ".objPreDelete"); 
    }

    /**
     *
     */
    protected final Person delegate;
    
    /**
     * A lazy initialized DatatypeFactory instance
     */
    private DatatypeFactory datatypeFactory = null;

    /**
     * @return a Datatype Factory Instance
     */
    protected synchronized DatatypeFactory xmlDatatypeFactory(
    ) throws RefException {
      	if(datatypeFactory == null) try {
        	datatypeFactory = DatatypeFactory.newInstance();
      	} catch (DatatypeConfigurationException e) {
        	throw new RefException(e.getMessage());
      	}
      	return datatypeFactory;
    }

}
