/*
 * ==================================================================== 
 * Project: openMDX, http://www.openmdx.org
 * Description: HTML Mapper 
 * Owner: the original authors. 
 * ====================================================================
 * 
 * This software is published under the BSD license as listed below.
 * 
 * Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the following
 * conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in
 *   the documentation and/or other materials provided with the
 *   distribution.
 * 
 * * Neither the name of the openMDX team nor the names of its
 *   contributors may be used to endorse or promote products derived
 *   from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * ------------------
 * 
 * This product includes or is based on software developed by other 
 * organizations as listed in the NOTICE file.
 */
package org.openmdx.application.mof.mapping.pimdoc.text;

import java.net.URI;
import java.time.Instant;
import java.util.stream.Stream;

import org.openmdx.application.mof.externalizer.spi.AnnotationFlavour;
import org.openmdx.application.mof.mapping.pimdoc.MagicFile;
import org.openmdx.application.mof.mapping.pimdoc.PIMDocConfiguration;
import org.openmdx.application.mof.mapping.pimdoc.spi.AbstractMapper;
import org.openmdx.application.mof.mapping.spi.MapperUtils;
import org.openmdx.base.Version;
import org.openmdx.base.exception.RuntimeServiceException;
import org.openmdx.base.exception.ServiceException;
import org.openmdx.base.io.Sink;
import org.openmdx.base.mof.cci.ModelElement_1_0;
import org.openmdx.base.mof.cci.Model_1_0;
import org.openmdx.base.mof.spi.PIMDocFileType;

/**
 * HTML Mapper
 */
abstract class HTMLMapper extends AbstractMapper {

	protected HTMLMapper(
		Sink sink, 
		Model_1_0 model, 
		URI entryName, 
		AnnotationFlavour annotationFlavour, 
		PIMDocConfiguration configuration
	) {
		super(sink, model, annotationFlavour, configuration);
		this.entryName = entryName.getPath().substring(1);
	}
	
	protected HTMLMapper(Sink sink, Model_1_0 model, MagicFile entryType, AnnotationFlavour annotationFlavour, PIMDocConfiguration configuration) {
		super(sink, model, annotationFlavour, configuration);
		this.entryName = entryType.getFileName(MagicFile.Type.TEXT);
	}

	protected HTMLMapper(Sink sink, ModelElement_1_0 element, AnnotationFlavour annotationFlavour, PIMDocConfiguration configuration) {
		super(sink, element.getModel(), annotationFlavour, configuration);
		this.entryName = getEntryName(element);
	}

	private final String entryName;
	
    static String FRAME_NAME = "frame";
	private static final String UNCHECKED_BOX = "&#x2610;";
	private static final String CHECKED_BOX = "&#x2611;";
    
    protected String getMapperId() {
        return getClass().getSimpleName() + " " + Version.getImplementationVersion();
    }
	
    public void createArchiveEntry() {
    	fileHeader();
        htmlPage();
        fileFooter();
    }

	protected void htmlPage() {
		printLine("<html>");
        htmlHead();
        htmlBody();
        printLine("</html>");
	}
    
    protected void fileHeader(
    ) {
        printLine("<!DOCTYPE html>");
        fileGenerated();
    }

	protected void fileGenerated() {
		printLine("<!--");
        printLine(" !");
        printLine(" ! Generated by ", getMapperId());
        printLine(" ! Generated at ", Instant.now().toString());
        printLine(" !");
        printLine(" ! GENERATED - DO NOT CHANGE MANUALLY");
        printLine(" !");
        printLine(" !-->");
	}

    protected void fileFooter() {
    }

    protected void htmlHead() {
        printLine("<head>");
        printLine("\t<meta charset=\"utf-8\">");
        printLine("\t<link rel=\"stylesheet\" href=\"", getFileURL(MagicFile.STYLE_SHEET, MagicFile.Type.TEXT), "\" />");
        htmlTitle(getTitle());
        printLine("</head>");
    }

	protected void htmlTitle(final String title) {
		if(title != null) {
	        printLine("\t<title>", title, "</title>");
        }
	}
    	
	/**
	 * Provide the entry name (using HTML entries)
	 * 
	 * @param element the model element used to derive the entry name
	 * 
	 * @return the entry name
	 */
    static String getEntryName(ModelElement_1_0 element){
    	try {
	    	final StringBuilder entryName = new StringBuilder(
	    		element.getModel().toJavaPackageName(element, null).replace('.', '/')
	    	);
			entryName.append('/').append(element.getName()).append(PIMDocFileType.TEXT.extension());
	    	return entryName.toString();
		} catch (ServiceException exception) {
			throw new RuntimeServiceException(exception);
    	}
    }
	
    @Override
	protected String getEntryName() {
    	return this.entryName;
	}

	protected abstract String getBaseURL();

    protected String getFileURL(
    	MagicFile magicFile,
    	MagicFile.Type type
    ) {
    	return getBaseURL() + magicFile.getFileName(type);
    }

    protected String getHref(
    	ModelElement_1_0 element
    ){
    	if(element.isPackageType() || element.isClassType() || element.isStructureType()){
        	return getBaseURL() + getEntryName(element);
    	} else {
			final ModelElement_1_0 container = getContainer(element);
        	return getBaseURL() + getEntryName(container) + "#" + element.getName();
		}
    }

    protected static String getDisplayName(
    	ModelElement_1_0 element
    ) {
    	String qualifiedName = element.getQualifiedName();
    	return (element.isPackageType() ? qualifiedName.substring(0, qualifiedName.lastIndexOf(':')) : qualifiedName).replace(":", "::");
    }
    
    protected void mapAnnotation(
    	String indent, 
    	ModelElement_1_0 element
    ) {
    	final String annotation  = (String)element.objGetValue("annotation");
		if(annotation != null && !annotation.trim().isEmpty()) {
			printLine(indent, "<div class=\"uml-comment\">");
			final String rendered = renderAnnotation(annotation);
			if(rendered.contains("<pre>")) {
				print(rendered);
			} else {
				MapperUtils.wrapText(indent + '\t', rendered, this::printLine);
			}
			printLine(indent, "</div>");
		}
    }
    
	protected Stream<ModelElement_1_0> streamElements(){
		return this.model.getContent().stream();
	}
	
	static String renderBox(boolean checked) {
		return checked ? CHECKED_BOX : UNCHECKED_BOX;
	}
	
    protected abstract String getTitle();
    
    protected abstract void htmlBody();
    
}
